# TS

## TS 与 JS 区别

1. js 属于动态编程语言，边解释边执行，错误只有在运行时才能发现
2. ts 属于静态编程语言，在写的时候就会发现错误了（ts 不能直接执行，需要先编译成 js）
3. ts 完全支持 js，可以直接转换
4. ts 有类型支持，有强大的代码类型提示

## JS 注意点

1. 值只有 undefined 时，if(undefined) 不执行， if(!undefined) 会执行
2. undefined 显示声明后不初始化，但 typeof 未声明的变量也会 undefined，所以尽量声明就初始化
3. 值只有 null 时，if(null) 不执行，if(!null) 会执行
4. 逻辑上空对象指针 typeof null == object
5. Number 上 0.1 + 0.2 !== 0.3
6. 数值转换 把非数值转化为数值的三种方法
   1. Number()  NaN() 判断是否能转为 Number
   2. parseInt()
   3. parseFloat()

## 类型注释

* 给变量添加类型约束（可以显示标记出代码中的意外行为，从而降低了发生错误的可能性）

## ts 的类型

1. ts 的常用类型分为两种
   1. js 已有类型
      1. 原始类型 number/string/boolean/null/undefined/symbol
      2. 对象类型 object（包括 数组/对象/函数等对象
   2. ts 新增类型
      1. 联合类型
      2. 自定义类型（类型别名）
      3. 接口
      4. 元组
      5. 字面量类型
      6. 枚举
      7. void
      8. any
      9. 等等
2. 类型推论在 ts 中，在某些没有明确指定类型的情况下，ts 的类型推论机制会自动提供类型
3. 联合类型：在 ts 中 | 竖线，在 ts 中称为 联合类型。即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种
4. 类型别名：当类型名特别长时，就需要定义个别名
5. 数组类型：number[] 或者 Array<number>
6. 函数：实际上指的是 函数参数和返回值的类型
   1. 定义单个函数
   2. 统一定义函数格式
   3. 函数返回值类型 void
      1. 函数没有返回值时使用
      2. 函数没写 return
      3. 只写了 return，没有具体的返回值
      4. return 的是 undefined
   4. 函数-可选参数：在参数后面加 ?
   5. 可选和默认值的区别
      1. 相同点：调用函数时，可以少传参数
      2. 区别：设置了默认值之后，就时可选的了，不屑就会使用默认值；可选的参数一定有值
      3. 注意：不能一起使用，优先使用默认值
7. 对象类型-单独使用
   1. 格式：方法有两种写法： 普通函数 和 箭头函数
    const 对象名: {
      属性名1：类型1，
      属性名2?：类型2，
      方法名1(形参1: 类型1，形参2: 类型2)： 返回值类型,
      方法名2:(形参1: 类型1，形参2: 类型2) => 返回值类型
    } = { 属性名1: 值1，属性名2：值2  }
8. 接口： 当一个对象类型被多次使用时，以下两种方式来 描述对象 的类型，以达到复用的目的
   1. 类型别名 type
   2. 接口 interface
   3. 语法：interface 接口名 { 属性1: 类型1, 属性2: 类型2 }
   4. 接口和类型 的区别 interface （接口）和 type （类型别名）的对比：
      1. 相同点：都可以给对象指定类型
      2. 不同点：
         1. 接口，只能为对象制定类型。可以继承
         2. 类型别名，不仅可以为对象制定类型，实际上可以为 任意类型 指定别名
   5. 接口继承：如果两个接口之间有相同的属性或方法，可以将 公共的属性或方法抽离出来，通过继承来实现复现
      1. interface 接口2 extends 接口1 { 属性1: 类型1 // 接口2中特有的类型 }
      2. interface a { x: number; y: number }
      3. interface b extends a { z: number }
9. 元组
   1. 元组是一种特殊的数组
       1. 约定了元素的个数
       2. 约定了特定索引对应的数据类型
10. 字面量类型
    1. let str1 = "hello ts" 是 string 类型
    2. const str2 = "hello ts" 是 hello ts 类型
    3. type Gender = "girl" | "boy" 声明一个类型，它的值是 "girl" "boy"
    4. let g1: Gender = "girl" 正确
    5. let g2: Gender = "boy" 正确
    6. let g3: Gender = "man"
11. 枚举（enum）：类似于 字面量 + 联合类型组合 的功能，来描述一个值，该值只能是一组命名常量中的一个
    1. enum 枚举名 { 可取值1, 可取值2 }
    2. 使用方法：枚举名.可取值
    3. 注意：
       1. 一般枚举名称以大写字母开头
       2. 枚举中的多个值之间通过 ,(逗号) 分隔
       3. 定义好枚举后，直接使用枚举名称作为类型注解
       4. 枚举也分 数值枚举 和 字符串枚举
          1. 数值枚举：默认情况下，枚举的值是 数值。默认为 从 0 开始自增的数值，也可以给枚举中的成员初始化值
          2. enum Direction { Up = 10, Down, Left, Right} // Down -> 11、Left -> 12、Right -> 13
          3. enum Direction { Up = "", Down = "Down", Left = "Left", Right = "Right"}
       5. 字符串枚举没有自增行为。字符串枚举的每个成员必须有初始值
12. any 类型
    1. 任意的，当类型设置为 any 时，就取消了类型的限制
    2. 使用 any 的场景
        1. 函数就是不挑类型
        2. 临时使用 any 来避免 书写很长、很复杂的类型
        3. 隐式 any
            1. 声明变量不提供类型也不提供默认值
            2. 定义函数时，参数不给类型
    3. 不推荐使用 any，会使得 TS 变为 AnyScript（失去 TS 类型保护的优势）

## 网络优化

### DNS 预解析

link 标签的 ref 属性设置 dns-prefetch，提前获取域名对应的 IP 地址

### 使用缓存

减轻服务端压力，快速得到数据（强缓存/协商缓存）

### 使用 CDN （内容分发网络）

用户与服务器的物理距离对响应时间也有影响
内容分发网络（CDN）是一组分散在不同地理位置的 web 服务器，用来给用户更高效地发送内容。
选择用来发送内容的服务器是基于网络距离的衡量的标准的。
eg：选跳数（hop）最少的或者响应时间最快的服务器

### 压缩响应

压缩组件通过减少 HTTP 请求产生的响应包的大小，从而降低传输时间的方式来提高性能。
eg：从 HTTP1.1 开始，Web 客户端可以通过请求中的 Accept-Encoding 头来标识对压缩的支持（这个请求头会列出一系列的压缩方法）
如果 Web 服务器看到请求头中的这个头，就会使用客户端列出的方法中的一种来压缩响应。Web 服务器通过响应中的 Content-Encoding 头来告知 Web 客户端使用哪种方法进行的压缩。
eg：通常压缩 HTML 文档，脚本和样式表的压缩也是值得的（包括 XML 和 JSON 在内的任何文本响应都应该是值得被压缩的）。图片和 PDF 文件不应该被压缩，因为它们已经被压缩了

### 使用多个域名

Chrome 等现代化浏览器，都会有同域名限制并发下载数，不同浏览器&版本都不一样，使用不同的域名可以最大化下载线程，但注意保持在 2～4 个域名内，以避免 DNS 查询损耗。

### 避免图片 src 为空

当 src 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求：
其中：

  1. IE 向页面所在的目录发送请求
  2. Safari、Chrome、Firefox 向页面本身发送请求
  3. Opera 不执行任何操作

## 页面渲染优化

### Webkit 渲染引擎流程

1. 处理 HTML 并构建 DOM 树
2. 处理 CSS 构建 CSS 规则树（CSSOM）
3. DOM tree 和 CSSOM Tree 合成一棵树 Render Tree
4. 根据渲染树来布局，计算每个节点的位置
5. 调用 GPU 绘制，合成图层，显示在屏幕上

### 避免 css 阻塞

css 影响 renderTree 的构建，会阻塞页面的渲染，因此应该【尽早（将 css 放在 head 标签里）和尽快（启用CDN 实现静态资源加载速度的优化）的】将 css 资源加载

### 降低 css 选择器的复杂度

浏览器读取选择器，遵循的原则是从选择器的右边到左边读取

1. 减少嵌套：最多不要超过三层，并且后代选择器的开销较大
2. 避免使用通配符，对用到的元素进行匹配即可
3. 利用继承，避免重复匹配和定义
4. 正确使用 类选择器 和 id选择器

### 避免使用 css 表达式

css 表达式会被频繁地计算

### 避免 js 阻塞

js 可以修改 CSSOM 和 DOM，因此 js 会阻塞页面的解析和渲染，并且会等待 css 资源的加载。
js 会抢走渲染引擎的控制权，所以需要给 js 资源添加 defer 或者 async，延迟 js 脚本的执行

### 使用外链接的 js 和 css

### 首屏加载优化

1. 使用骨架屏或者动画优化用户体验
2. 资源按需加载，首页不需要的资源延迟加载

### 减少重绘和回流

1. 增加多个节点使用 documentFragment：不是真实 dom 的b富恩，不会引起重绘和回流
2. 用 translate 代替 top，因为 top 会触发回流，但是 translate 不会。所以 translate 会比 top 节省一个 layout 的时间
3. 使用 visibility 替换 display: none，因为前者只会引起重绘，后者会引发回流（改变了布局）；opacity 代替 visiability，但 visiability 会触发重绘（paint），但 opacity 不会
4. 把 DOM 离线后修改。eg：先把 DOM 给 display: none（有一次 Reflow）
5. 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量
  eg: for(let i = 0; i < 1000; i++) {
    console.log(document.querySelector('.test').style.offsetTop)
  }
6. 尽量少用 table 布局，table 布局得到话，每次有单元格布局改变，都会进行整个 table 回流重绘
7. 最好别频繁的操作 DOM 节点，最好把需要操作的方式，提前写成 class，之后需要修改。只需要修改一次，需要修改的时候，直接修改 className，做成一次性更新多条 css DOM 树形，一次回流重绘总比多次回流重绘要付出的成本低得多
8. 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层

## JS 中的性能优化

1. 使用件委托
2. 防抖和节流
3. 尽量不要使用 JS 动画
   css3 动画 和 canvas 动画 都比 JS 动画性能好
4. 多线程
   复杂的计算开启 webWorker 进行计算，避免页面假死
5. 计算结果缓存
   减少运算次数，比如 vue 中的computed

## 图片的优化

1. 雪碧图
   借助减少 http 请求次数来进行优化
2. 图片懒加载

## 列表优化

### 虚拟列表

1. 按需显示，即只对可见区域进行渲染，对非可见区域的数据不渲染或部分渲染的技术
2. 获取数据本身并没有那么消耗性能，渲染的过程才消耗时间
3. 渲染部分抽离出来，消耗时间就减少了
4. <https://juejin.cn/post/6844903982742110216#heading-5>
5. IntersectionObserver 监听减少性能消耗
6. 如果包含图片，由于图片不会发送网络请求，无法保证图片的高度是否已经完成加载，所以可以使用 ResizeObserver

### 懒加载（延迟加载）

1. 在长网页中延迟加载图像，是一种很好优化网页性能的方式
2. <https://juejin.cn/post/6844903614138286094>
3. 用户滚动到它们之前，可视化区域的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载使得网页加载更快。还可以帮助减少服务器负载
4. 适用于图片很多，页面很长的电商网站场景中
5. 为什么使用懒加载
   1. 提升用户体验
   2. 减少无效资源的加载
   3. 防止并发加载的资源过多会阻塞 js 的加载
6. 懒加载原理
   1. 将页面上的图片大的 src 属性设为空字符串，而图片的真实路径则设置在 data-original 属性中
   2. 当页面滚动的时候需要去监听 scroll 属性，在 scroll 事件的回调中，判断懒加载的图片是否进入可视区域
   3. 图片在可视化内将图片的 src 属性设置为 data-original 的值

### 预加载

1. 将所需的资源提前请求加载到本地，在后续使用时直接从缓存取资源
2. 为什么使用预加载
   1. 在网页全部加载之前，对一些内容进行加载，以提供给用户更好的体验，减少等待的时间
   2. 如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间处于空白，直到所有内容加载完毕
3. 方法：
   1. 使用HTML标签 <img src="http://pic26.nipic.com/20121213/6168183 0044449030002.jpg" style="display:none"/>
   2. 使用 Image 对象
    /**
       <script src="./myPreload.js"></script>
    //myPreload.js文件
    var image= new Image()
    image.src="<http://pic26.nipic.com/20121213/6168183> 004444903000 2.jpg"
     */
   3. 使用 XMLHttpRequest 对象，虽然存在跨域问题，但会精细控制预加载过程
   4. 使用PreloadJS库
    PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。

### 懒加载与预加载的对比

1. 两者区别是一个延迟甚至不加载，一个是提前加载
2. 懒加载对服务器前端有一定的缓解压力作用
3. 预加载则会增加服务器前端压力

### 分页加载

### 分片渲染

1. 一个执行完再执行下一个
2. 建立一个队列，通过定时器进行渲染
3. <https://juejin.cn/post/7121551701731409934>

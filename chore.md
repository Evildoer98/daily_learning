# 浏览器

## 导航

### DNS 查询（解决网址问题）

1. 未访问过的网站，必须进行域名系统（DNS）查询
2. DNS 查询只发生在我们第一次访问一个网站时
3. IP 地址可能会被缓存一段时间，所以二次访问会更快，因为不需要进行 DNS 查询

### TCP（Transmission COntrol ）

1. 一旦浏览器知道了网站的 IP 地址，将尝试 TCP 三次握手（称 SYN-SYN-ACK 或者 SYN、SYN-ACK、ACK，因为 TCP 有三个消息传输，用于协商和启动两台计算机的 TCP 会话）与持有资源的服务器建立连接。
2. TCP 是传输控制协议的缩写，是一种通信标准，使应用程序和计算设备能够在网络上交换信息。它被设计用来在互联网上发送数据包，并确保数据和信息在网络上成功传递。
3. TCP 握手是一种机制，旨在让两个想要相互传递信息的实体（在我们的例子中是浏览器和服务器）在传输数据之前协商好连接的参数。
4. TCP连接（双向连接）已经通过3次握手建立，TLS协商可以开始。

### TLS 协商

1. 对于通过 HTTPS 建立的安全连接，需要进行另一次握手。这种握手（TLS协商）决定了哪个密码将被用于加密通信，验证服务器，并在开始实际的数据传输之前建立一个安全的连接。
2. 传输层安全（TLS）是现已废弃的安全套接字层（SSL）的继任者，是一种加密协议，旨在通过计算机网络提供通信安全。该协议被广泛用于电子邮件和即时通讯等应用，但它在确保 HTTPS安全方面的应用仍然是最公开的。由于应用程序可以使用或不使用 TLS（或SSL）进行通信，因此客户（浏览器）有必要要求服务器建立 TLS 连接。

* 客户端 hello。浏览器向服务器发送一条信息，其中包括它所支持的TLS版本和密码套件，以及一串随机字节，称为 客户端随机数。

  1. 服务器 hello 和证书。服务器发回一条信息，其中包括服务器的SSL证书、服务器选择的密码套件和服务器随机数，这是服务器生成的另一个随机字节串。
  2. 认证。浏览器会向颁发证书的机构核实服务器的 SSL 证书。这样，浏览器就可以确定服务器就是它所说的那个人。
  3. 预主密码。浏览器会再发送一串随机的字节，称为主密钥，用浏览器从服务器的 SSL 证书上获取的公钥进行加密。主密码只能由服务器用私钥解密。
  4. 使用私钥。服务器解密预主密码。
  5. 创建会话密钥。浏览器和服务器从客户端随机数、服务器随机数和预主密码中生成会话密钥。
  6. 客户端完成。浏览器向服务器发送一个消息，说它已经完成。
  7. 服务器完成。服务器向浏览器发送一个消息，表示它也完成了。
  8. 安全对称加密实现。握手完成，通信可以继续使用会话密钥。

## 获取数据

### HTTP 请求

1. 请求方法 - POST, GET, PUT, PATCH, DELETE 等
   1. URI - 是统一资源识别符的缩写。URIs 用于识别互联网上的抽象或物理资源，如网站或电子邮件地址等资源。一个 URI 最多可以有 5 个部分
   2. scheme：用于说明使用的是什么协议
   3. authority：用于识别域名
   4. path：用于显示资源的确切路径
   5. query：用于表示一个请求动作
   6. fragment：用来指代资源的一部分

### HTTP 响应

1. 状态代码 - 例如：200、400、401、504网关超时等（我们的目标是 200 状态代码，因为它告诉我们一切正常，请求是成功的）
2. 响应头字段 - 保存关于响应的额外信息，如它的位置或提供它的服务器。

### TCP 慢启动和拥塞算法

TCP 慢启动 是一种平衡网络连接速度的算法。 第一个数据包将是 14kb（或更小），其工作方式是逐渐增加传输的数据量，直到达到预定的阈值。 从服务器接收到每个数据包后，客户端以 ACK 消息响应。 由于连接容量有限，如果服务器发送太多数据包太快，它们将被丢弃。 客户端不会发送任何 ACK 消息，因此服务器会将此解释为拥塞。 这就是拥塞算法发挥作用的地方。 他们监控发送的数据包和 ACK 消息的流，以确定流量的最佳速率并创建稳定的流量流。

## HTML 解析

### 词法分析

### 构建 DOM

### 预加载器 & 使页面更快

## 解析 CSS

解析完 HTML 之后，就该解析 CSS（在外部 CSS 文件和样式元素中找到）并构建 CSSOM 树（CSS 对象模型）。
当浏览器遇到 CSS 样式表时，无论是外部样式表还是嵌入式样式表，它都需要将文本解析为可用于设置布局样式的内容。 浏览器将 CSS 变成的数据结构称为 CSSOM。 DOM 和 CSSOM 遵循相似的概念，因为它们都是树，但它们是不同的数据结构。 就像从我们的 HTML 构建 DOM 一样，从 CSS 构建 CSSOM 被认为是一个「渲染阻塞 」过程。

### 词法分析和构建 CSSOM

CSS 规则是从右到左阅读的，这意味着如果我们有这样的代码： section p { color: blue; }, 浏览器将首先查找页面上的所有 p 标签，然后它会查看这些 p 标签中是否有一个 section 标签作为父标签。 如果查找能够命中，它将应用这个 CSS 规则

## 执行 JavaScript

在解析 CSS 并创建 CSSOM 的同时，还会下载其他资产，包括 JavaScript 文件。 这要归功于我们在之前文章中提到的预加载器。

预加载器就像一个解析器，它在主解析器处理 HTML 代码时扫描 HTML 文件。 它的作用是查找样式表、脚本或图片（也需要从服务器检索）等资源并请求它们。 希望在解析 HTML 时，这些资源已经下载并准备好进行处理。

所以，当我们从服务器获取 Javascript 文件后，代码被解释、编译、解析和执行。 计算机无法理解 Javascript 代码，只有浏览器可以。 JS 代码需要被翻译成计算机可以使用的东西，这是 Javascript 浏览器引擎的工作（不要与浏览器引擎混淆）。 根据浏览器的不同，JS 引擎可以有不同的名称和不同的工作方式。

### Javascript 引擎

1. 编译: 在编译过程中，一个称为编译器的软件将用高级语言编写的代码一次性转换为机器代码。 创建一个目标文件，该文件可以在任何机器上运行。 采取这些步骤后，就可以执行代码了。
2. 解释: 在解释过程中，解释器逐行检查 Javascript 代码并立即执行。 没有进行编译，因此没有创建目标代码（代码的输出由解释器本身使用其内部机制创建）。 旧版本的 Javascript 使用这种类型的代码执行。
3. 即时编译( JIT Compilation ): 即时编译是给定语言的解释器的一个特性，它试图同时利用编译和解释。 是在纯编译期间，代码是在执行之前被编译，然而在 JIT 编译中，代码在执行时（在运行时）被编译。 所以我们可以说源代码是动态转换为机器代码的。 较新版本的 Javascript 使用这种类型的代码执行。

* 编译器：编译代码
* 解释器：运行代码
* JIT 编译器：在运行代码时进行编译

### Javascript 代码是如何处理的

1. 当 Javascript 代码进入 Javascript 引擎时，它首先被解析。 这意味着代码被读取，并且在这种情况下，代码被转换为称为抽象语法树 (AST) 的数据结构。 代码将被拆分成与语言相关的部分（如 function 或 const 关键字），然后所有这些部分将构建抽象语法树。

2. 构建 AST 后，它会被翻译成机器代码并立即执行，因为现代 Javascript 使用即时编译。 这段代码的执行将由 Javascript 引擎完成，利用称为“调用堆栈”的东西。

* 调用堆栈是解释器（如 Web 浏览器中的 JavaScript 解释器）跟踪其在调用多个函数的脚本中的位置的机制——当前正在运行的函数以及从该函数中调用的函数等。

## 创建可访问（无障碍）树

## 渲染树

在解析阶段构建的树（DOM、CSSOM）被组合成一种叫做渲染树的东西。 这用于计算最终将绘制到屏幕上的所有可见元素的布局。 渲染树的目的是确保页面内容以正确的顺序绘制元素。 它将作为在屏幕上显示像素的绘画过程的输入。

### 结合 DOM 和 CSSOM

浏览器将开始在 DOM 树的根部施展魔法并遍历每个可见节点。 一些节点，如脚本或元标记是不可见的，因此它们被忽略。 还有一些节点会被 CSS 隐藏（例如 display: "none" 属性），它们也会被忽略。 我们只对可见节点感兴趣，因为只有它们对屏幕上的输入有影响。
对于在 DOM 中找到的每个可见节点，将在 CSSOM 中找到相应的规则并应用它们。

### 布局（回流）阶段

* 渲染树包含有关显示哪些节点及其计算样式的信息，但不包含每个节点的尺寸或位置。
接下来需要做的是计算这些节点在设备视口（浏览器窗口内）内的确切位置及其大小。 这个阶段称为布局（在 Chrome、Opera、Safari 和 Internet Explorer 中）或重排（在 Firefox 中），但它们的意思相同。 浏览器在渲染树的根部开始这个过程并遍历它。

* 回流步骤不会只发生一次，而是每次我们更改 DOM 中影响页面布局的某些内容时，即使是部分更改，都会触发回流。 重新计算元素位置的情况示例如下：

1. 在 DOM 中添加或删除元素
2. 调整浏览器窗口大小
3. 更改元素的宽度、位置或使其浮动

### 绘画（重绘）阶段

* 在浏览器决定哪些节点需要可见并计算出它们在视口中的位置后，就可以在屏幕上绘制它们（渲染像素）了。 这个阶段也被称为光栅化阶段，浏览器将在布局阶段计算的每个盒子转换为屏幕上的实际像素。

* 就像布局阶段一样，绘画阶段不会只发生一次，而是每次我们改变屏幕上元素的外观时。 这些情况的例子是：

1. 改变元素的轮廓
2. 改变背景颜色
3. 改变不透明度或可见性

* 绘画意味着浏览器需要将元素的每个视觉部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换元素（如按钮和图像），并且需要超快地完成。 为了确保重绘可以比初始绘制更快地完成，屏幕上的绘图通常被分解成几层。 如果发生这种情况，则需要进行合成。

### 分层和合成

* 合成是一种将页面的各个部分分成层的技术，分别绘制它们并在称为合成器线程的单独线程中合成为页面。 当文档的各个部分绘制在不同的层中并相互重叠时，合成是必要的，以确保它们以正确的顺序绘制到屏幕上并且内容被正确呈现。

* 回流和重绘，都是昂贵的，尤其是在像手机这样处理能力低的设备上。 这就是为什么在处理 DOM 更改时我们应该尝试优化它们。 有些动作只会触发重绘，有些动作会同时触发回流和重绘。
